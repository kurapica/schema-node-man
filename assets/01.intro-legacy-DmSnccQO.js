!function(){function n(n){return function(n){if(Array.isArray(n))return t(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,e){if(n){if("string"==typeof n)return t(n,e);var r={}.toString.call(n).slice(8,-1);return"Object"===r&&n.constructor&&(r=n.constructor.name),"Map"===r||"Set"===r?Array.from(n):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?t(n,e):void 0}}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function t(n,t){(null==t||t>n.length)&&(t=n.length);for(var e=0,r=Array(t);e<t;e++)r[e]=n[e];return r}System.register(["./index-legacy-x-IfpgQS.js","./el-collapse-item-legacy-DgOQooZ4.js","./showandtry.vue_vue_type_style_index_0_lang-legacy-ButtEzb9.js","./el-tabs-legacy-BfoBVhSE.js","./tryit.vue_vue_type_script_setup_true_lang-legacy-DaEcxeu_.js"],function(t,e){"use strict";var r,u,a,o,i,l,c,s,f,m,d;return{setters:[function(n){r=n.d,u=n.f,a=n.e,o=n.h,i=n.i,l=n.m,c=n.w,s=n.au,f=n.av,m=n.aw},null,function(n){d=n._},null,null],execute:function(){t("default",r({__name:"01.intro",setup:function(t){return function(t,e){var r=f,y=m;return a(),u("section",null,[o(s,null,{default:c(function(){return n(e[0]||(e[0]=[i("\n            # Schema-Node 数据节点系统\n\n            ## 01. 简介\n\n            本系统的核心功能是使用JSON格式描述数据类型，数据类型包括，基础数据类型，枚举类型，结构体类型，数组类型和函数类型。\n\n            除了常规的数据类型外，为了在前后端都可以执行统一操作，函数类型被定义为使用JSON描述，可在前后端编译为对应函数。无法基于JSON描述定义的函数，可以在后端服务定义后，仅提供函数申明即可。前端可以识别并决定是在前端执行，还是调用后端服务。\n\n            基于数据类型创建前端数据节点,由数据节点完成数据的组织，保存，校验以及联动。数据类型可以配置关联，利用函数类型和其它数据节点进行联动，推送数据经函数计算后实现修改默认值，黑白名单，可用性，数据类型等等处理。\n\n            可以点击下面按钮进行尝试，在选择学科后，才会显示学科成绩列表，列表的学科白名单由选择学科决定，它的黑名单由已经配置过成绩的学科决定。这些处理可以在类型中展示的字段数据关联列表中查看如何配置。绿色的类型可以点击进一步查看。\n        ",-1)]))}),_:1}),e[4]||(e[4]=i()),o(d,{type:"test.person"}),e[5]||(e[5]=i()),e[6]||(e[6]=l("br",null,null,-1)),e[7]||(e[7]=i()),o(y,{accordion:""},{default:c(function(){return[o(r,{title:"本次开源内容"},{default:c(function(){return[o(s,null,{default:c(function(){return n(e[1]||(e[1]=[i("\n                    本次开源的部分是剥离后端后，仅前端专用的部分，包含两个库，和一个前端类型配置管理器。\n\n                    1. [schema-node](https://github.com/kurapica/schema-node): 无依赖的类型数据节点系统，基于数据类型生产数据节点，并基于各自的关系实现数据订阅。\n\n                    2. [schema-node-vueview](https://github.com/kurapica/schema-node-vueview): 基于Vue3和ElmentPlus实现的数据节点视图库，我们可以为数据类型注册不同的视图实现，这里提供的是默认实现。\n\n                    3. [schema-node-man](https://github.com/kurapica/schema-node-man): 前端用类型配置管理器，可以上传，下载自定义类型，可以自动缓存。类型下载后可以配合前两个库在各个项目中使用。\n                ",-1)]))}),_:1})]}),_:1}),e[3]||(e[3]=i()),o(r,{title:"应用和服务器架构-非本次开源内容"},{default:c(function(){return[o(s,null,{default:c(function(){return n(e[2]||(e[2]=[i("\n                    如果考虑一个应用如何基于数据类型定制，每个应用的实体都应有一个应用ID，例如用户ID等。它在数据库中表现为存储在多张表中的数据，则我们可以依据存储表结构为应用定义字段，一个字段即一个表结构。\n\n                    例如为用户应用指定一个用户信息使用结构体类型，那么在数据表中，每个用户对应一行，如果指定一个成绩单，那么显然使用数组类型表示多行即可。\n\n                    如此，我们可以为一个应用定义多个字段，每个字段指定一个数据类型，系统即可基于结构自动创建出表结构。\n\n                    当客户端基于应用ID请求应用数据时，服务器可以把所需的数据类型信息，枚举值(按需加载),数据统一打包发给客户端，减轻访问压力。\n\n                    客户端可以使用统一的提交数据接口将应用的变更数据提交给服务器，除了保存变更外，应用字段间可以配置关联，形成数据推送链，常用于将数据进行过滤，转换之后进行结果汇总。这样无需等待实际步骤后再取数据进行处理，数据量很大时，节省的资源会比较可观。\n\n                    如果字段申明为广播类型，也可以在数据计算推送后，进行特定协议的广播处理。\n\n                    服务器可以分为配置管理服务器和应用服务器，配置管理仅内网操作，修改后，应用修改可以直接推送给各个应用服务器，自动完成在线的数据库表结构更新等操作。\n\n                    ![架构图](./assets/img/architecture.zh.png)\n                ",-1)]))}),_:1})]}),_:1})]}),_:1})])}}}))}}})}();

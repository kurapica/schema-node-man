!function(){function e(e){return function(e){if(Array.isArray(e))return t(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,n){if(e){if("string"==typeof e)return t(e,n);var a={}.toString.call(e).slice(8,-1);return"Object"===a&&e.constructor&&(a=e.constructor.name),"Map"===a||"Set"===a?Array.from(e):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?t(e,n):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function t(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,a=Array(t);n<t;n++)a[n]=e[n];return a}System.register(["./index-legacy-x-IfpgQS.js"],function(t,n){"use strict";var a,r,i,o,l,s;return{setters:[function(e){a=e.d,r=e.c,i=e.e,o=e.w,l=e.i,s=e.au}],execute:function(){t("default",a({__name:"10.app.main",setup:function(t){return function(t,n){return i(),r(s,null,{default:o(function(){return e(n[0]||(n[0]=[l("\n        ### 10.4 Main Application\n\n        Data entry and enabling the data push chain present a challenge in establishing a mutual exclusion lock for data updates. Whether using distributed or local locks, a lock key is required. Typically, this is done in the form {application name}_{target ID}.\n\n        However, if data push involves multiple applications, for example, each application aggregates data for a layer of managers, then a safe approach is to identify a sufficiently high-level manager as the target ID to establish a lock.\n\n        To clarify this step, you can specify a master application for the application (this only applies if the application's fields are reference fields). This allows the mutual exclusion lock to be locked at a higher level, avoiding issues.\n\n        ### TODO\n\n        Further discussion of the application's features awaits further discussion after the release of the basic backend SDK.\n    ",-1)]))}),_:1})}}}))}}})}();

import{d as o,f as i,e as d,h as a,i as t,m as n,w as s,au as r,F as l}from"./index-ab2O0MvO.js";const c=o({__name:"09.view",setup(u){return(p,e)=>(d(),i(l,null,[a(r,null,{default:s(()=>[...e[0]||(e[0]=[t("\n        ## 09. Custom Views\n\n        To create custom views, you can refer to the default implementations provided in `schema-node-vueview`. There are a few important points to keep in mind:\n\n        1. In Vue, the `node` data node is passed into the component via a prop with a fixed name. Once received, you should use `toRaw` to unwrap it into the actual data node instance. Otherwise, you’ll get a Vue-wrapped reactive object, which may cause issues during further processing.\n    ",-1)])]),_:1}),e[3]||(e[3]=t()),e[4]||(e[4]=n("pre",null,[t("        "),n("code",null," \n            const props = defineProps<{ node: ScalarNode }>()\n            const scalarNode = toRaw(props.node)\n        "),t("\n    ")],-1)),e[5]||(e[5]=t()),a(r,null,{default:s(()=>[...e[1]||(e[1]=[t("\n        2. Avoid using `watch` to observe changes in the node’s data or state. Instead, use the subscription methods provided by the node itself for more accurate and efficient tracking.\n    ",-1)])]),_:1}),e[6]||(e[6]=t()),e[7]||(e[7]=n("pre",null,[t("        "),n("code",null,"\n            // declare the state\n            const state = reactive<{\n                data?: any,\n                display?: any,\n                disable?: boolean,\n                require?: boolean,\n                readonly?: boolean,\n            }>({})\n\n            // data & state watcher\n            let dataWatcher: Function | null = null\n            let stateWatcher: Function | null = null\n\n            onMounted(() => {\n                // subscribe data change\n                dataWatcher = scalarNode.subscribe(() => {\n                    const data = scalarNode.rawData // use rawData to allow error data\n                    state.data = data\n                    state.display = `${!isNull(data) ? data : ''}`\n                }, true)\n\n                // subscribe state change, like invisible\n                stateWatcher = scalarNode.subscribeState(() => {\n                    state.disable = scalarNode.rule.disable\n                    state.require = scalarNode.require\n                    state.readonly = scalarNode.readonly\n                }, true)\n            })\n\n            // dispose subscription\n            onUnmounted(() => {\n                if (dataWatcher) dataWatcher()\n                if (stateWatcher) stateWatcher()\n            })\n        "),t("\n    ")],-1)),e[8]||(e[8]=t()),a(r,null,{default:s(()=>[...e[2]||(e[2]=[t("\n        3. Once the custom view is defined, there are two ways to register it for a specific type.\n    ",-1)])]),_:1}),e[9]||(e[9]=t()),e[10]||(e[10]=n("pre",null,'        // override the default view\n        regSchemaTypeView("test.persons", waterFallView)\n\n        // register view with skin, use `skin` in schemaview to active the skin view\n        regSchemaTypeView("test.persons", waterFallView, "waterfall")\n    ',-1))],64))}});export{c as default};

!function(){function e(e){return function(e){if(Array.isArray(e))return t(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,n){if(e){if("string"==typeof e)return t(e,n);var a={}.toString.call(e).slice(8,-1);return"Object"===a&&e.constructor&&(a=e.constructor.name),"Map"===a||"Set"===a?Array.from(e):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?t(e,n):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function t(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,a=Array(t);n<t;n++)a[n]=e[n];return a}System.register(["./index-legacy-Cnd4X8U8.js"],function(t,n){"use strict";var a,r,o,i,s,u,l,c,d;return{setters:[function(e){a=e.d,r=e.f,o=e.e,i=e.h,s=e.i,u=e.m,l=e.w,c=e.au,d=e.F}],execute:function(){t("default",a({__name:"09.view",setup:function(t){return function(t,n){return o(),r(d,null,[i(c,null,{default:l(function(){return e(n[0]||(n[0]=[s("\n        ## 09. Custom Views\n\n        To create custom views, you can refer to the default implementations provided in `schema-node-vueview`. There are a few important points to keep in mind:\n\n        1. In Vue, the `node` data node is passed into the component via a prop with a fixed name. Once received, you should use `toRaw` to unwrap it into the actual data node instance. Otherwise, you’ll get a Vue-wrapped reactive object, which may cause issues during further processing.\n    ",-1)]))}),_:1}),n[3]||(n[3]=s()),n[4]||(n[4]=u("pre",null,[s("        "),u("code",null," \n            const props = defineProps<{ node: ScalarNode }>()\n            const scalarNode = toRaw(props.node)\n        "),s("\n    ")],-1)),n[5]||(n[5]=s()),i(c,null,{default:l(function(){return e(n[1]||(n[1]=[s("\n        2. Avoid using `watch` to observe changes in the node’s data or state. Instead, use the subscription methods provided by the node itself for more accurate and efficient tracking.\n    ",-1)]))}),_:1}),n[6]||(n[6]=s()),n[7]||(n[7]=u("pre",null,[s("        "),u("code",null,"\n            // declare the state\n            const state = reactive<{\n                data?: any,\n                display?: any,\n                disable?: boolean,\n                require?: boolean,\n                readonly?: boolean,\n            }>({})\n\n            // data & state watcher\n            let dataWatcher: Function | null = null\n            let stateWatcher: Function | null = null\n\n            onMounted(() => {\n                // subscribe data change\n                dataWatcher = scalarNode.subscribe(() => {\n                    const data = scalarNode.rawData // use rawData to allow error data\n                    state.data = data\n                    state.display = `${!isNull(data) ? data : ''}`\n                }, true)\n\n                // subscribe state change, like invisible\n                stateWatcher = scalarNode.subscribeState(() => {\n                    state.disable = scalarNode.rule.disable\n                    state.require = scalarNode.require\n                    state.readonly = scalarNode.readonly\n                }, true)\n            })\n\n            // dispose subscription\n            onUnmounted(() => {\n                if (dataWatcher) dataWatcher()\n                if (stateWatcher) stateWatcher()\n            })\n        "),s("\n    ")],-1)),n[8]||(n[8]=s()),i(c,null,{default:l(function(){return e(n[2]||(n[2]=[s("\n        3. Once the custom view is defined, there are two ways to register it for a specific type.\n    ",-1)]))}),_:1}),n[9]||(n[9]=s()),n[10]||(n[10]=u("pre",null,'        // override the default view\n        regSchemaTypeView("test.persons", waterFallView)\n\n        // register view with skin, use `skin` in schemaview to active the skin view\n        regSchemaTypeView("test.persons", waterFallView, "waterfall")\n    ',-1))],64)}}}))}}})}();

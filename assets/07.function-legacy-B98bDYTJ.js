System.register(["./index-legacy-B7jAuSoa.js","./showandtry.vue_vue_type_style_index_0_lang-legacy-DraTnC6O.js","./el-tabs-legacy-CnS_tUAz.js","./tryit.vue_vue_type_script_setup_true_lang-legacy-ixy7qZq0.js"],(function(n,e){"use strict";var t,u,l,r,s,c,i,a,f;return{setters:[function(n){t=n.d,u=n.f,l=n.e,r=n.h,s=n.i,c=n.w,i=n.am,a=n.m},function(n){f=n._},null,null],execute:function(){n("default",t({__name:"07.function",setup:function(n){return function(n,e){return l(),u(a,null,[r(i,null,{default:c((function(){return e[0]||(e[0]=[s("\n        ## 07. 函数类型\n\n        函数对于数据节点而言，最重要的是它的参数和返回值，基于它们我们可以很好的关联各个数据节点。实际我们并不关心它的具体实现，一些特殊的函数，类似获取天气信息都无法直接通过JSON进行配置。\n\n        常规的做法，是在服务器中注册一部分功能函数供数据节点使用，它们可以在类型配置中进行选择，也可以在其它JSON格式定义的函数中被直接使用。前端可以基于函数的标志和表达式定义情况，来判定是直接前端执行还是后端调用。\n\n        普通的函数通过配置表达式列表来实现功能，通常如果函数返回值为单值，默认最后一个表达式即返回值。可以看到最后一个表达式标记为蓝色，如果表达式返回值和函数返回值不匹配，会标红。\n    ")])})),_:1}),e[3]||(e[3]=s()),r(f,{type:"test.nosubjects"}),e[4]||(e[4]=s()),r(i,null,{default:c((function(){return e[1]||(e[1]=[s("\n        对于需要返回结构体的函数，只需要参数或者表达式的参数名和结构体的字段一致即可，例如下例中，仅需要组合参数即可。\n    ")])})),_:1}),e[5]||(e[5]=s()),r(f,{type:"test.gensubjectscore"}),e[6]||(e[6]=s()),r(i,null,{default:c((function(){return e[2]||(e[2]=[s("\n        定义时，可以尝试右侧输入数据，进行计算。\n\n        因为JSON描述很难构建出循环结构，或者可以构建但会造成整体过于复杂。所以，表达式采用了纯函数的做法，包括if判定都由函数完成。\n        \n        这里比较特殊的是针对数组的循环处理，为了复用可以处理单个元素的函数，通过配置表达式的调用方式来执行。\n\n        1. 直接调用(call): 普通调用模式。\n        2. 数组映射(map): 将一个数组的元素映射为其它数据，取结果构成新数组。指定函数只操作单个元素，它的一个参数需要选择对应的元素数组。\n        3. 数组规约(reduce): 将一个数组的元素集合初始值依次传给函数，返回结果作为新的初始值和下一个元素传给函数，所有元素处理后，返回最后结果，通常用于合计等处理。\n        4. 首先满足(first): 将一个数组的元素传入函数，返回第一个结果为true的元素。\n        5. 最后满足(last): 将一个数组的元素倒序传入函数，返回第一个结果为true的元素。\n        6. 过滤(filter): 将一个数组的元素传入函数，保留结果为true的元素构成新数组。\n\n        可以自行尝试。函数编辑时可选项目都是基于相关类型进行配置。\n    ")])})),_:1})],64)}}}))}}}));

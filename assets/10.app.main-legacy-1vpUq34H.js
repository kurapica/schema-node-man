!function(){function n(n){return function(n){if(Array.isArray(n))return t(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,r){if(n){if("string"==typeof n)return t(n,r);var e={}.toString.call(n).slice(8,-1);return"Object"===e&&n.constructor&&(e=n.constructor.name),"Map"===e||"Set"===e?Array.from(n):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?t(n,r):void 0}}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function t(n,t){(null==t||t>n.length)&&(t=n.length);for(var r=0,e=Array(t);r<t;r++)e[r]=n[r];return e}System.register(["./index-legacy-DHxPH3K1.js"],function(t,r){"use strict";var e,o,u,i,a,c;return{setters:[function(n){e=n.d,o=n.c,u=n.e,i=n.w,a=n.i,c=n.au}],execute:function(){t("default",e({__name:"10.app.main",setup:function(t){return function(t,r){return u(),o(c,null,{default:i(function(){return n(r[0]||(r[0]=[a("\n        ### 10.4 主应用\n\n        数据录入，启用数据推送链，这里的一个困难是如何为更新数据加互斥锁，无论采用分布式锁还是本地，都需要有一个锁定用的键。通常来说，采用{应用名}_{目标ID}的形式就可以。\n\n        但是如果数据推送牵扯到多个应用，例如每个应用对于一层管理人，按照层级关系向上汇总数据，那么稳妥的做法是找到一个足够上级的管理人作为目标ID，来构建锁。\n        \n        为了明确这个步骤，可以为应用指定主应用（仅当应用的字段是引用字段时出现），这样互斥锁可以锁在比较高的层级，避免问题。\n\n        ### TODO\n\n        应用更多的部分有待基础后端SDK推出后进一步讨论。\n    ",-1)]))}),_:1})}}}))}}})}();

!function(){function e(e){return function(e){if(Array.isArray(e))return t(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,n){if(e){if("string"==typeof e)return t(e,n);var a={}.toString.call(e).slice(8,-1);return"Object"===a&&e.constructor&&(a=e.constructor.name),"Map"===a||"Set"===a?Array.from(e):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?t(e,n):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function t(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,a=Array(t);n<t;n++)a[n]=e[n];return a}System.register(["./index-legacy-x-IfpgQS.js","./showandtry.vue_vue_type_style_index_0_lang-legacy-ButtEzb9.js","./el-tabs-legacy-BfoBVhSE.js","./tryit.vue_vue_type_script_setup_true_lang-legacy-DaEcxeu_.js"],function(t,n){"use strict";var a,s,i,r,o,u,c,l,y;return{setters:[function(e){a=e.d,s=e.f,i=e.e,r=e.h,o=e.i,u=e.w,c=e.au,l=e.F},function(e){y=e._},null,null],execute:function(){t("default",a({__name:"03.scalar",setup:function(t){return function(t,n){return i(),s(l,null,[r(c,null,{default:u(function(){return e(n[0]||(n[0]=[o("\n        ## 03. Basic Data Types\n\n        Basic data types are unstructured types and are stored in the database as the smallest units of data. Typically, custom basic types are not allowed, but you can define new types based on existing basic types. However, if the goal is simply to configure constraints like minimum or maximum values, it's better to define them within a struct.\n\n        In some special cases, custom definitions are necessary. For example, in this configuration service, we define `schema.valuetype`, which is based on the string type but has a custom view registered for it. This allows it to be used for selecting data types. Note that it is only used for selecting data types—not for selecting namespaces or functions.\n\n        Fields declared with this type can directly use the registered view for interaction. This includes use cases like function return types, struct field types, and more.\n    ",-1)]))}),_:1}),n[2]||(n[2]=o()),r(y,{type:"system.schema.valuetype"}),n[3]||(n[3]=o()),r(c,null,{default:u(function(){return e(n[1]||(n[1]=[o("\n        If you pay attention to how the type is displayed, you’ll notice that we actually use the `schema.scalardefine` type to describe a basic data type. You can try it out briefly just to get a sense of how it works—but in practical applications, there is rarely a need to define additional basic data types.\n    ",-1)]))}),_:1}),n[4]||(n[4]=o()),r(y,{type:"system.schema.scalarschema"})],64)}}}))}}})}();
